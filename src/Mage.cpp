//---------------LI Xian 2013/12/21---------------//
//Chuck plugin, mage -real time speech synthesis.


//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------



// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>


// 
#include <string>
#include <fstream>


#include <pthread.h>
//include file for mage, must be loaded after "chuck_dl.h", I don't know why
#include "mage.h"

void * genThread(void *argv);
// declaration of chugin constructor
CK_DLL_CTOR(Mage_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(Mage_dtor);

// example of getter/setter
CK_DLL_MFUN(Mage_setParam);
CK_DLL_MFUN(Mage_getParam);

CK_DLL_MFUN(Mage_setFreq);
CK_DLL_MFUN(Mage_getFreq);

CK_DLL_MFUN(Mage_setDur);
CK_DLL_MFUN(Mage_getDur);

CK_DLL_MFUN(Mage_ready);
CK_DLL_MFUN(Mage_popLabel);
CK_DLL_MFUN(Mage_computeDuration);
CK_DLL_MFUN(Mage_computeParameters);


CK_DLL_MFUN(Mage_setFramebeat);

CK_DLL_MFUN(Mage_initMage);

CK_DLL_MFUN(Mage_startSynthesis);
CK_DLL_MFUN(Mage_stopSynthesis);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(Mage_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT Mage_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class Mage
{
public:
    // constructor
    Mage( t_CKFLOAT fs)
    {
        m_param = 0;
		mage=new MAGE::Mage;
		//initMage();
	}
	~Mage()
	{
		;
	}
	void initMage(string engine, string engineConfigFile,string _labelFile,float alpha)
	{
	
		mage->addEngine(engine,engineConfigFile);
		mage->setDefaultEngine(engine);
		labelFile=_labelFile;
		mage->setAlpha(alpha);

		if(this->mage->getLabelQueue()->isEmpty())
		{
			printf("fill label queque\n");
			fillLabelQueue();
		}
	}
	
	void startSynthesis()
	{
		pthread_create(&thread,NULL,genThread,this);
	}
	void stopSynthesis()
	{
		pthread_cancel(thread);
		pthread_join(thread,NULL);
	}
    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
		this->mage->updateSamples();
			// get the generated samples
		//printf("current Label:%s\n",this->mage->getLabel().getQuery().c_str());
		//printf("sample:%f\n",(SAMPLE)this->mage->popSamples());
		return	(SAMPLE)this->mage->popSamples();

		//return in;
		
        
    }
	int ready()
	{
		if(mage->ready()) 
		{
		//	printf("ready\n");
			return 1;
		}
		//printf("not ready\n");
		return 0;
	}
	int popLabel()
	{
		if(mage->popLabel()) 
		{
			//printf("pop label\n");
			return 1;
		}
		//printf("pop failed\n");
		return 0;
	}
	float computeDuration();
	void computeParameters();

    // set parameter example
    float setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // get parameter example
    float getParam() { return m_param; }
 	
	float setFramebeat(t_CKFLOAT p)
	{
		m_framebeat=p;
		return p;
	}

	float setFreq(t_CKFLOAT p)
	{
		m_freq=p;
		mage->setPitch(m_freq,0);
		return p;
	}

	float getFreq(){return m_freq;}

	float setDur(t_CKFLOAT p)
	{
		m_dur=p;
		double d[5]={m_dur,m_dur,m_dur,m_dur,m_dur};
		mage->setDuration(d,2);
		return p;
	}

	float getDur(){return (float)mage->getDuration();}

	void fillLabelQueue()
	{	
			
		MAGE::Label label;
		
		string s( this->labelFile );
		parsefile( s );
		
		this->fill = false;
		
		while( !labellist.empty() )
		{
			string q = labellist.front();
			label.setQuery( q );
					
			labellist.pop();
			
			this->mage->pushLabel( label );

	//		printf("current Label:%s\n",label.getQuery().c_str());
	//		printf("push label\n");
		}
		
		this->fill = true;
	}
  
	void parsefile( std::string filename )
	{
		string line;
		ifstream myfile( filename.c_str() );
		
		if( !myfile.is_open() )
		{
			printf( "could not open file %s",filename.c_str() );
			return;
		}
		
		for( int k = 0; getline( myfile, line ); k++ )
			this->labellist.push( line );
		
		myfile.close();
		
		return;
	}
	
 	//MAGE
	MAGE::Mage *mage;
	
	pthread_t thread;
	//labels
	bool fill;
	string labelFile;
	std::queue<string> labellist;
	
	
	float m_framebeat; // dirty way
private:
    // instance data
    float m_param;
	float m_freq;
	float m_dur;


};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Mage )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Mage");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Mage", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, Mage_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, Mage_dtor);
    
    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, Mage_tick, NULL, 1, 1);
    
    // NOTE: if this is to be a UGen with more than 1 channel, 
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, Mage_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, Mage_getParam, "float", "param");


   // example of adding setter method
    QUERY->add_mfun(QUERY, Mage_setFramebeat, "float", "framebeat");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");
   
	// example of adding setter method
    QUERY->add_mfun(QUERY, Mage_setFreq, "float", "freq");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, Mage_getFreq, "float", "getFreq");
	
    // example of adding setter method
    QUERY->add_mfun(QUERY, Mage_setDur, "float", "dur");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, Mage_getDur, "float", "getDur");
	

	QUERY->add_mfun(QUERY,Mage_ready,"int","ready");
	QUERY->add_mfun(QUERY,Mage_popLabel,"int","popLabel");
	QUERY->add_mfun(QUERY,Mage_computeDuration,"float","computeDuration");
	QUERY->add_mfun(QUERY,Mage_computeParameters,"void","computeParameters");
    
	QUERY->add_mfun(QUERY,Mage_initMage,"void","init");
    QUERY->add_arg(QUERY, "string", "engine");
    QUERY->add_arg(QUERY, "string", "engineConfigFile");
    QUERY->add_arg(QUERY, "string", "_labelFile");
    QUERY->add_arg(QUERY, "float", "alpha");



	QUERY->add_mfun(QUERY,Mage_startSynthesis,"void","startSynthesis");
	QUERY->add_mfun(QUERY,Mage_stopSynthesis,"void","stopSynthesis");


    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    Mage_data_offset = QUERY->add_mvar(QUERY, "int", "@m_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(Mage_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, Mage_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    Mage * bcdata = new Mage(API->vm->get_srate());
	//bcdata->mage=new MAGE::Mage();
	//bcdata->labelFile=Chuck_String("test");
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, Mage_data_offset) = (t_CKINT) bcdata;
    
}


// implementation for the destructor
CK_DLL_DTOR(Mage_dtor)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // check it
    if( bcdata )
    {
        // clean up
        delete bcdata;
        OBJ_MEMBER_INT(SELF, Mage_data_offset) = 0;
        bcdata = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(Mage_tick)
{
    // get our c++ class pointer
    Mage * c = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(c) *out = c->tick(in);
	//printf("out:%f\n",*out);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(Mage_setParam)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->setParam(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(Mage_getParam)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->getParam();
}


// example implementation for setter
CK_DLL_MFUN(Mage_setFramebeat)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->setFramebeat(GET_NEXT_FLOAT(ARGS));
}




// example implementation for setter
CK_DLL_MFUN(Mage_setFreq)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->setFreq(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(Mage_getFreq)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->getFreq();
}

CK_DLL_MFUN(Mage_setDur)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->setDur(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(Mage_getDur)
{
    // get our c++ class pointer
    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->getDur();
}

CK_DLL_MFUN(Mage_ready)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    RETURN->v_int = bcdata->ready();
}

CK_DLL_MFUN(Mage_popLabel)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    RETURN->v_int = bcdata->popLabel();
}

CK_DLL_MFUN(Mage_computeDuration)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    RETURN->v_float = bcdata->computeDuration();
}

CK_DLL_MFUN(Mage_computeParameters)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    bcdata->computeParameters();
}


CK_DLL_MFUN(Mage_initMage)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);

	string t1=GET_NEXT_STRING(ARGS)->str;
	string t2=GET_NEXT_STRING(ARGS)->str;
	string t3=GET_NEXT_STRING(ARGS)->str;
	float t4=GET_NEXT_FLOAT(ARGS);
    // set the return value
    //bcdata->initMage(GET_NEXT_STRING(ARGS)->str,GET_NEXT_STRING(ARGS)->str,GET_NEXT_STRING(ARGS)->str,GET_NEXT_FLOAT(ARGS));
    bcdata->initMage(t1,t2,t3,t4);
}

CK_DLL_MFUN(Mage_startSynthesis)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    bcdata->startSynthesis();
}


CK_DLL_MFUN(Mage_stopSynthesis)
{

    Mage * bcdata = (Mage *) OBJ_MEMBER_INT(SELF, Mage_data_offset);
    // set the return value
    bcdata->stopSynthesis();
}

float Mage::computeDuration()
{
		// prepare the model
		mage->prepareModel();

		// compute the corresponding durations taking into account the model
		// and if set, the interpolation and/or duration functions set by the user
		mage->computeDuration();
		// compute the corresponding parameters taking into account the model
		// and if set, the interpolation and/or duration functions set by the user
		mage->computeParameters ();

		// optimize the generated parameters
		mage->optimizeParameters();


		//return mage->getDuration();
		return 0.0;
}

void Mage::computeParameters()
{

	if(mage->ready())
	{
	
		mage->computeParameters();
		mage->optimizeParameters();

	}
}

void * genThread(void *argv)
{
	printf( "running genThread here\n" );
	Mage * c = (Mage *) argv;
	double updateFunction[5];
	
	while( 1 )
	{ 
		pthread_testcancel();
		if( c->mage->ready() )
		{
			if( c->mage->popLabel() )
			{
				// prepare the model
				c->mage->prepareModel();

				// compute the corresponding durations taking into account the model
				// and if set, the interpolation and/or duration functions set by the user
				c->mage->setDuration(updateFunction,3);

				c->mage->computeDuration();
				printf("compute duration\n");

				//change duration to sync to beat
				for(int i=0;i<5;i++)
					updateFunction[i]= c->m_framebeat/c->mage->getDuration(); // framebeat? should have a better name..
				c->mage->setDuration(updateFunction,2);
				printf("update duration\n");
				// compute duration again, quick and dirty
				c->mage->computeDuration();
				printf("compute again\n");
				// compute the corresponding parameters taking into account the model
				// and if set, the interpolation and/or duration functions set by the user
				c->mage->computeParameters ();

				// optimize the generated parameters
				c->mage->optimizeParameters();

				usleep( 100 );
			}
		}
		else
		{
			usleep( 1000 );
		}
	}
	
	return ( NULL );
}


